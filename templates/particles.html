<svg id="particles"></svg>

{% block extra_scripts %}
  <script>
    // Design Variables
    const colors = { dots: '#ebf0f3', nodes: ['#6e3bea', '#26d198', '#1a82ff'] };
    const horizontalSpacing = 104;
    const verticalSpacing = 30;
    const horizontalOffset = horizontalSpacing / 4;
    const verticalOffset = verticalSpacing / 2;
    const radius = 7;

    let data;
    let container;
    let containerHeight;
    let containerWidth;
    let columnsCount;
    let rowsCount;
    let dotsCount;
    let svg;
    let loop;

    // https://raw.githubusercontent.com/jashkenas/underscore/95e007ed57be8927c4b6344dabb684d055fd89c9/underscore.js
    function debounce(func, wait, immediate) {
      var timeout, args, context, timestamp, result;

      function now() {
        return Date.now || function() {
          return new Date().getTime();
        };
      }

      var later = function() {
        var last = now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          }
        }
      };

      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };

      debounced.clear = function() {
        clearTimeout(timeout);
        timeout = context = args = null;
      };

      return debounced;
    };

    const addNode = () => {
      const dot = data.dots[Math.floor(Math.random() * data.dots.length)];
      const unique = !data.nodes.find(n => n.cx === dot.cx && n.cy === dot.cy);

      if (unique) {
        data.nodes.push({
          key: generateId(),
          cx: dot.cx,
          cy: dot.cy,
          stroke: colors.nodes[Math.floor(Math.random() * colors.nodes.length)],
        });
      } else {
        data.nodes = data.nodes.filter(n => n.cx !== dot.cx || n.cy !== dot.cy);
      }

      svg.selectAll('circle.node').data(data.nodes, d => d.key)
        .enter().append('circle')
          .classed('node', true)
            .attr('cx', d => d.cx)
            .attr('cy', d => d.cy)
            .attr('fill', 'transparent')
            .attr('r', 1)
            .attr('stroke', d => d.stroke)
            .attr('stroke-width', 1)
        .transition()
          .duration(2000)
            .attr('r', radius);

      svg.selectAll('circle.node').data(data.nodes, d => d.key)
        .exit()
        .transition()
          .duration(1000)
            .attr('r', 0)
            .attr('stroke', 'transparent')
        .remove();

      manageNodeConnections(dot);
    };

    const build = () => {
      if (loop) {
        clearInterval(loop);
      }

      svg = d3.select('#particles');
      data = { connections: [], dots: [], nodes: [] };
      
      svg.selectAll('circle.dot').data(data.dots).exit().remove();
      svg.selectAll('circle.node').data(data.nodes).exit().remove();
      svg.selectAll('line.connection').data(data.connections).exit().remove();

      container = document.getElementById('particles').parentElement;
      containerHeight = container.offsetHeight;
      ContainerWidth = container.offsetWidth;
      columnsCount = Math.floor((container.offsetWidth + horizontalOffset) / horizontalSpacing) + 1;
      rowsCount = Math.floor((container.offsetHeight + verticalOffset) / verticalSpacing) + 1;
      dotsCount = Math.floor(columnsCount * rowsCount);

      for (var i = 0; i < dotsCount; i++) {
        const column =  Math.floor(i % columnsCount);
        const row = Math.floor(i / columnsCount);

        data.dots.push({
          cx: Math.floor(column * horizontalSpacing) + horizontalOffset + (row % 2 ? horizontalSpacing / 2 : 0),
          cy: Math.floor(row * verticalSpacing) + verticalOffset,
        });
      }

      svg.attr('height', '100%').attr('width', '100%');

      svg.selectAll('circle.dot').data(data.dots)
          .enter().append('circle')
            .classed('dot', true)
              .attr('cx', d => d.cx)
              .attr('cy', d => d.cy)
              .attr('fill', colors.dots)
              .attr('fill-opacity', 0)
              .attr('r', 1)
          .transition()
            .duration(2000)
              .attr('fill-opacity', 0.5);

      setTimeout(() => {
        loop = setInterval(() => {
          addNode();
        }, 1000);
      }, 2000);
    };

    const connectNodes = (existing, added) => {
      const getEnds = () => {
        let ends = {};

        // vertical
        if (added.cx === existing.cx) {
          ends.x1 = added.cx;
          ends.x2 = existing.cx;

          if (added.cy > existing.cy) {
            ends.y1 = added.cy - radius;
            ends.y2 = existing.cy + radius;
          } else {
            ends.y1 = added.cy + radius;
            ends.y2 = existing.cy - radius;
          }
        // angular
        } else {
          const h = Math.round(radius * 0.85);
          const v = Math.round(radius * 0.57);

          if (added.cx > existing.cx) {
            ends.x1 = added.cx - h;
            ends.x2 = existing.cx + h;
          } else {
            ends.x1 = added.cx + h;
            ends.x2 = existing.cx - h;
          }

          if (added.cy > existing.cy) {
            ends.y1 = added.cy - v;
            ends.y2 = existing.cy + v;
          } else {
            ends.y1 = added.cy + v;
            ends.y2 = existing.cy - v;
          }
        }

        return ends;
      };

      const getGradient = () => {
        const colors = `${added.stroke.slice(1)}-${existing.stroke.slice(1)}`;
        let positions = '';

        if (added.cx > existing.cx) {
          positions += '100-0-';
        } else if (added.cx < existing.cx) {
          positions += '0-100-';
        } else {
          positions += '0-0-';
        }

        if (added.cy > existing.cy) {
          positions += '100-0';
        } else if (added.cy < existing.cy) {
          positions += '0-100';
        } else {
          positions += '0-0';
        }

        return `${colors}-${positions}`;
      };

      const key = generateId();
      const ends = getEnds();
      let stroke = added.stroke === existing.stroke ? added.stroke : getGradient();

      // perfectly vertical gradients do not work with gradientUnits: objectBoundingBox (default)
      // https://github.com/OriginProtocol/company-website/issues/2#issuecomment-359883885
      if (stroke.match(/0-0-(100-0|0-100)/)) {
        stroke = stroke.replace(/-\d+-\d+-\d+-\d+/, `-${added.cx}-${existing.cx}-${added.cy}-${existing.cy}`);

        if (!document.getElementById(stroke)) {
          const defs = d3.select('#particles > defs');
          const lg = defs.append('linearGradient')
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('id', stroke)
            .attr('x1', ends.x1)
            .attr('x2', ends.x2)
            .attr('y1', ends.y1)
            .attr('y2', ends.y2);

          lg.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', `#${stroke.slice(0, 6)}`);

          lg.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', `#${stroke.slice(7, 13)}`);
        }
      }

      if (stroke.match('-')) {
        stroke = `url(#${stroke})`;
      }

      // line originates from newly added node
      data.connections.push(Object.assign({}, ends, { key, stroke }));

      svg.selectAll('line.connection').data(data.connections, c => c.key)
        .enter().append('line')
          .classed('connection', true)
            .attr('stroke', d => d.stroke)
            .attr('stroke-width', 1)
            .attr('x1', d => d.x1)
            .attr('x2', d => d.x1)
            .attr('y1', d => d.y1)
            .attr('y2', d => d.y1)
          .transition()
            .delay(2000)
            .duration(2000)
              .attr('x2', d => d.x2)
              .attr('y2', d => d.y2);
    };

    const disconnectNodes = dot => {
      data.connections = data.connections.filter(c => {
        return (Math.abs(dot.cx - c.x1) >= radius * 2 || Math.abs(dot.cy - c.y1) >= radius * 2) &&
               (Math.abs(dot.cx - c.x2) >= radius * 2 || Math.abs(dot.cy - c.y2) >= radius * 2);
      });

      svg.selectAll('line.connection').data(data.connections, c => c.key)
        .exit()
        .transition()
          .duration(1000)
            .attr('x2', d => d.x1)
            .attr('y2', d => d.y1)
        .remove();
    };

    // could probably use some recursion
    // but it helps to visualize
    const generateGradients = () => {
      const defs = d3.select('#particles').append('defs');
      let combinedColors = [];

      colors.nodes.forEach(c => {
        colors.nodes.filter(d => c !== d).forEach(d => {
          if (!combinedColors.find(col => col === `${c}-${d}`)) {
            combinedColors.push(`${c.slice(1)}-${d.slice(1)}`);
          }

          if (!combinedColors.find(col => col === `${d}-${c}`)) {
            combinedColors.push(`${d.slice(1)}-${c.slice(1)}`);
          }
        });
      });

      let combinedPositions = [];

      combinedColors.forEach(c => {
        // bottom-right-to-top-left
        combinedPositions.push({
          id: `${c}-100-0-100-0`,
          x1: '100%',
          x2: '0%',
          y1: '100%',
          y2: '0%',
        });

        // bottom-left-to-top-right
        combinedPositions.push({
          id: `${c}-0-100-100-0`,
          x1: '0%',
          x2: '100%',
          y1: '100%',
          y2: '0%',
        });

        // top-left-to-bottom-right
        combinedPositions.push({
          id: `${c}-0-100-0-100`,
          x1: '0%',
          x2: '100%',
          y1: '0%',
          y2: '100%',
        });

        // top-right-to-bottom-left
        combinedPositions.push({
          id: `${c}-100-0-0-100`,
          x1: '100%',
          x2: '0%',
          y1: '0%',
          y2: '100%',
        });
      });

      combinedPositions.forEach(p => {
        const lg = defs.append('linearGradient')
          .attr('id', p.id)
          .attr('x1', p.x1)
          .attr('x2', p.x2)
          .attr('y1', p.y1)
          .attr('y2', p.y2);

        lg.append('stop')
          .attr('offset', '0%')
          .attr('stop-color', `#${p.id.slice(0, 6)}`);

        lg.append('stop')
          .attr('offset', '100%')
          .attr('stop-color', `#${p.id.slice(7, 13)}`);
      });
    };

    const generateId = () => {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let text = '';

      while (text.length < 8) {
        text += chars.charAt(Math.floor(Math.random() * chars.length));
      }

      return text;
    };

    const manageNodeConnections = dot => {
      const added = data.nodes.find(n => dot.cx === n.cx && dot.cy === n.cy);

      if (added) {
        const adjacentDots = [
          { cx: dot.cx, cy: dot.cy - verticalSpacing * 2 },
          { cx: dot.cx + horizontalSpacing / 2, cy: dot.cy - verticalSpacing },
          { cx: dot.cx + horizontalSpacing / 2, cy: dot.cy + verticalSpacing },
          { cx: dot.cx, cy: dot.cy + verticalSpacing * 2 },
          { cx: dot.cx - horizontalSpacing / 2, cy: dot.cy + verticalSpacing },
          { cx: dot.cx - horizontalSpacing / 2, cy: dot.cy - verticalSpacing },
        ];

        adjacentDots.forEach(d => {
          const node = data.nodes.find(n => d.cx === n.cx && d.cy === n.cy);

          if (node) {
            connectNodes(node, added);
          }
        });
      } else {
        disconnectNodes(dot);
      }
    };

    const debouncedBuild = debounce(build, 400);

    // there may be a better way to defer execution until dependencies are met
    // but only run if included in a certain template
    window.addEventListener('load', build);
    window.addEventListener('load', generateGradients);
    window.addEventListener('resize', debouncedBuild);
  </script>
{% endblock %}
